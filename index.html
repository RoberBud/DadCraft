
<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Zombie Maze Simulator</title>
  <style>
    body {
      background-color: #0a0f1c;
      color: #fff;
      font-family: sans-serif;
      text-align: center;
      padding-top: 50px;
    }
    #maze-container {
      display: flex;
      justify-content: center;
      margin-top: 20px;
    }
    #maze {
      display: grid;
      grid-template-columns: repeat(15, 20px);
      transform: rotate(-90deg);
      transform-origin: top left;
    }
    .cell {
      width: 20px;
      height: 20px;
      border: 1px solid #ccc;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
    }
    .wall { background: gray; }
    .path { background: white; }
    .zombie { background: green; color: white; }
    .center { background: blue; }
    .oil { background: orange; }
    .visited { background: lightgreen; }
    .success { background: red; }
  </style>
</head>
<body>
  <h1>DadCraft</h1>
  <h2>PROTECT YOUR RICH OIL DADDY</h2>
  <div id="maze-container">
    <div id="maze"></div>
  </div>
  <button onclick="resetAndSimulate()">再次投胎</button>
  <script>
    const size = 15;
    const maze = [];
    const mazeDiv = document.getElementById('maze');
    const center = [7, 7];
    let animationStopped = false;

    function createMaze() {
      mazeDiv.innerHTML = '';
      for (let y = 0; y < size; y++) {
        maze[y] = [];
        for (let x = 0; x < size; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell path';
          mazeDiv.appendChild(cell);
          maze[y][x] = { el: cell, type: 'path' };
        }
      }

      // Add borders
      for (let i = 0; i < size; i++) {
        maze[0][i].type = 'wall';
        maze[0][i].el.className = 'cell wall';
        maze[i][0].type = 'wall';
        maze[i][0].el.className = 'cell wall';
        maze[i][size-1].type = 'wall';
        maze[i][size-1].el.className = 'cell wall';
      }

      // Add center
      maze[center[1]][center[0]].type = 'center';
      maze[center[1]][center[0]].el.className = 'cell center';

      // Add oil wells
      for (let i = 0; i < 5; i++) {
        const ox = Math.floor(Math.random() * (size - 4)) + 2;
        const oy = Math.floor(Math.random() * (size - 4)) + 2;
        if (maze[oy][ox].type === 'path') {
          maze[oy][ox].type = 'oil';
          maze[oy][ox].el.className = 'cell oil';
        }
      }

      // Add internal walls
      for (let i = 2; i < size - 2; i += 2) {
        for (let j = 2; j < size - 2; j++) {
          if (Math.random() < 0.3 && maze[i][j].type === 'path') {
            maze[i][j].type = 'wall';
            maze[i][j].el.className = 'cell wall';
          }
        }
      }
    }

    function bfs(start) {
      const queue = [start];
      const visited = Array.from({ length: size }, () => Array(size).fill(false));
      const prev = Array.from({ length: size }, () => Array(size).fill(null));
      visited[start[1]][start[0]] = true;

      while (queue.length > 0) {
        const [x, y] = queue.shift();
        if (x === center[0] && y === center[1]) break;
        for (const [dx, dy] of [[0,1],[1,0],[0,-1],[-1,0]]) {
          const nx = x + dx, ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size &&
              !visited[ny][nx] &&
              (maze[ny][nx].type === 'path' || maze[ny][nx].type === 'center')) {
            visited[ny][nx] = true;
            prev[ny][nx] = [x, y];
            queue.push([nx, ny]);
          }
        }
      }

      // Reconstruct path
      let path = [];
      let cur = center;
      while (cur && !(cur[0] === start[0] && cur[1] === start[1])) {
        path.push(cur);
        cur = prev[cur[1]][cur[0]];
      }
      if (cur) path.push(start);
      return path.reverse();
    }

    function animatePath(path, label) {
      let i = 0;
      function step() {
        if (animationStopped) return;
        if (i < path.length) {
          const [x, y] = path[i];
          if (maze[y][x].type === 'center') {
            maze[y][x].el.className = 'cell success';
            animationStopped = true;
            if (label === 'YOU') {
              alert('恭喜你到達終點');
            } else {
              alert('其實你並沒有一個富爸爸');
            }
            return;
          } else {
            maze[y][x].el.className = 'cell visited';
          }
          i++;
          setTimeout(step, 100);
        }
      }
      step();
    }

    function resetAndSimulate() {
      animationStopped = false;
      createMaze();
      const edges = [];
      for (let i = 1; i < size - 1; i++) {
        edges.push([i, 1]);
        edges.push([i, size - 2]);
        edges.push([1, i]);
        edges.push([size - 2, i]);
      }
      const selected = [];
      while (selected.length < 5) {
        const candidate = edges[Math.floor(Math.random() * edges.length)];
        if (!selected.some(([x, y]) => x === candidate[0] && y === candidate[1])) {
          selected.push(candidate);
        }
      }

      selected.forEach((start, index) => {
        const label = index === 0 ? 'YOU' : 'Z';
        maze[start[1]][start[0]].el.className = 'cell zombie';
        maze[start[1]][start[0]].el.textContent = label;
        const path = bfs(start);
        if (path.length > 0) {
          setTimeout(() => animatePath(path, label), index * 200);
        }
      });
    }

    createMaze();
  </script>
</body>
</html>
