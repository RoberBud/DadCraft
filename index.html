<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta charset="UTF-8">
  <title>https://i.postimg.cc/N0sLwv0c/A-digital-sci-fi-themed-artwork-with-a-deep-midnight-colored-background-Toward-the-center-right-of.jpg</title>
    <style>   
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&display=swap');
    body {
      background-color: #0a0f1c;
      color: #fff;
      font-family: sans-serif;
      text-align: center;
      padding-top: 100px;
    }
    #maze-container {
      display: flex;
      justify-content: center;
      margin-top: 20px;
      }

    #maze { display: grid; grid-template-columns: repeat(15, 20px); margin: 20px auto;}
    .cell { width: 20px; height: 20px; border: 1px solid #ccc; }
    .wall { background: gray; }
    .path { background: white; }
    .zombie { background: green; }
    .center { background: blue; }
    .oil { background: orange; }
    .visited { background: lightgreen; }
    .success { background: red; }

    .gradient-sub {
      font-family: 'Orbitron', sans-serif;
      font-size: 25px;
      font-weight: withe;
      color: #F0FFFF;
      position: relative;
      display: inline-block;
      text-shadow: 2px 2px 6px #001f4d;
      
    }  
    .gradient-stroke {
      font-family: 'Orbitron', sans-serif;
      font-size: 80px;
      font-weight: bold;
      background: linear-gradient(to bottom, #f9d976, #b87333); 
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      color: #2c3e50;
      position: relative;
      display: inline-block;
      
    }

    .gradient-stroke::before {
      webkit-text-stroke: 60px transparent; 
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      font-family: inherit;
      font-size: inherit;
      font-weight: inherit;
      background: linear-gradient(to bottom, #f9d976, #b87333); /* 淺金 → 銅金 */
      -webkit-background-clip: text;
      color: transparent;
      filter: drop-shadow(0 0 2px #f9d976);
      z-index: -1;
      -webkit-text-stroke: 2px #001f4d; 
      text-shadow: 2px 2px 6px #001f4d; 
      } 
    }

  </style>
</head>
<body background="https://i.postimg.cc/N0sLwv0c/A-digital-sci-fi-themed-artwork-with-a-deep-midnight-colored-background-Toward-the-center-right-of.jpg">
  <h1 class="gradient-stroke" data-text="DadCraft" style="font-size: 80px; margin-bottom: 20px;">DadCraft</h1>
  <h2 class="gradient-sub" data-text="PROTECT YOUR RICH OIL DADDY" style="font-size: 40px; margin-bottom: 0;">PROTECT YOUR RICH OIL DADDY</h2>
   <div id="maze-container">
        <div id="maze">
        </div>
  </div>

  <button onclick="resetAndSimulate()">再次投胎</button>
    <script>     
    const size = 15;
    const maze = [];
    const mazeDiv = document.getElementById('maze');
    const center = [7, 7];

    function createMaze() {
      mazeDiv.innerHTML = '';
      for (let y = 0; y < size; y++) {
        maze[y] = [];
        for (let x = 0; x < size; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell path';
          mazeDiv.appendChild(cell);
          maze[y][x] = { el: cell, type: 'path' };
        }
      }



      // Add walls
      for (let i = 0; i < size; i++) {
        maze[0][i].type = 'wall';
        maze[0][i].el.className = 'cell wall';
        maze[size-1][i].type = 'wall';
        maze[size-1][i].el.className = 'cell wall';
        maze[i][0].type = 'wall';
        maze[i][0].el.className = 'cell wall';
        maze[i][size-1].type = 'wall';
        maze[i][size-1].el.className = 'cell wall';
      }
      maze[5][6].type = 'wall';
      maze[5][6].el.className = 'cell wall';
      maze[5][7].type = 'wall';
      maze[5][7].el.className = 'cell wall';
      maze[5][8].type = 'wall';
      maze[5][8].el.className = 'cell wall';
      maze[5][9].type = 'wall';
      maze[5][9].el.className = 'cell wall';
      maze[6][5].type = 'wall';
      maze[6][5].el.className = 'cell wall';
      maze[7][5].type = 'wall';
      maze[7][5].el.className = 'cell wall';
      maze[8][5].type = 'wall';
      maze[8][5].el.className = 'cell wall';
      maze[9][5].type = 'wall';
      maze[9][5].el.className = 'cell wall';


      // Add center
      maze[center[1]][center[0]].type = 'center';
      maze[center[1]][center[0]].el.className = 'cell center';

      // Add oil wells
      for (let i = 0; i < 5; i++) {
        const ox = Math.floor(Math.random() * (size - 4)) + 2;
        const oy = Math.floor(Math.random() * (size - 4)) + 2;
        if (maze[oy][ox].type === 'path') {
          maze[oy][ox].type = 'oil';
          maze[oy][ox].el.className = 'cell oil';
        }
      }

      // Add internal walls
      for (let i = 2; i < size - 2; i += 2) {
        for (let j = 2; j < size - 2; j++) {
          if (Math.random() < 0.3 && maze[i][j].type === 'path') {
            maze[i][j].type = 'wall';
            maze[i][j].el.className = 'cell wall';
          }
        }
      }
    }

    function bfs(start) {
      const queue = [start];
      const visited = Array.from({ length: size }, () => Array(size).fill(false));
      const prev = Array.from({ length: size }, () => Array(size).fill(null));
      visited[start[1]][start[0]] = true;

      while (queue.length > 0) {
        const [x, y] = queue.shift();
        if (x === center[0] && y === center[1]) break;
        for (const [dx, dy] of [[0,1],[1,0],[0,-1],[-1,0]]) {
          const nx = x + dx, ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size &&
              !visited[ny][nx] &&
              (maze[ny][nx].type === 'path' || maze[ny][nx].type === 'center')) {
            visited[ny][nx] = true;
            prev[ny][nx] = [x, y];
            queue.push([nx, ny]);
          }
        }
      }

      // Reconstruct path
      let path = [];
      let cur = center;
      while (cur && !(cur[0] === start[0] && cur[1] === start[1])) {
        path.push(cur);
        cur = prev[cur[1]][cur[0]];
      }
      if (cur) path.push(start);
      return path.reverse();
    }

    function animatePath(path) {
      let i = 0;
      function step() {
        if (i < path.length) {
          const [x, y] = path[i];
          if (maze[y][x].type === 'center') {
            maze[y][x].el.className = 'cell success';
          } else {
            maze[y][x].el.className = 'cell visited';
          }
          i++;
          setTimeout(step, 100);
        }
      }
      step();
    }

    function resetAndSimulate() {
      createMaze();
      const edges = [];
      for (let i = 1; i < size - 1; i++) {
        edges.push([i, 1]);
        edges.push([i, size - 2]);
        edges.push([1, i]);
        edges.push([size - 2, i]);
      }
      const start = edges[Math.floor(Math.random() * edges.length)];
      maze[start[1]][start[0]].el.className = 'cell zombie';
      const path = bfs(start);
      if (path.length > 0) animatePath(path);
    }

    // Initialize
    createMaze();
  </script>

</body>
</html>
