<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta charset="UTF-8">
  <title>https://i.postimg.cc/tgzDNMDT/2025-08-15-105945.jpg</title>
    <style>   
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&display=swap');
    body {
      background-color: #0a0f1c;
      color: #fff;
      font-family: sans-serif;
      text-align: center;
      padding-top: 100px;
      background-image: url('https://i.postimg.cc/9XGP042H/background.png'); 
      background-repeat: no-repeat;           
      background-size: cover;                 
      background-position: center center;      
      margin: 0;
      margin-top: -130px;
      padding-bottom: 100px;
      

    }
    #maze-container {
      position: relative;
      display: flex;
      justify-content: center;
      margin-top: 20px;
      overflow: hidden;

      }

    #maze { display: grid; grid-template-columns: repeat(15, 20px); margin: 20px auto;}
    .cell { width: 20px; height: 20px; border: 1px solid #ccc; }
    .wall { background-image: url('https://i.postimg.cc/wMhxR9x3/image.jpg');
            background-size: cover;
            background-position: center;
          }
    .path { background: #FFF5CC; }
    .zombie { background-image: url('https://i.postimg.cc/tRsGS36k/638602776036030000.jpg');
              background-size: cover;
              background-position: center;
              }
    .center { background-image: url('https://i.postimg.cc/SRv0K5Cj/A-realistic-portrait-of-an-Arab-oil-tycoon-focusing-only-on-the-head-He-is-wearing-a-traditional-a.jpg');
              background-size: cover;
              background-position: center;
            }
    .oil { background-image: url('https://i.postimg.cc/KcnmNvF8/image.jpg');
            background-size: cover;
            background-position: center;
          }
    .visited-you { background-image: url('https://i.postimg.cc/RZxsT4S4/A-simple-icon-style-illustration-of-a-desert-boot-suitable-for-walking-in-the-desert-placed-on-a-pa.jpg');
               background-size: cover;
               background-position: center;
              }
    .visited { background-image: url('https://i.postimg.cc/tRsGS36k/638602776036030000.jpg');
               background-size: cover;
               background-position: center;
              }
    .visited_overlap { background-image: url('https://i.postimg.cc/mZnBBX4K/2025-08-15-102032.jpg');
               background-size: cover;
               background-position: center;
              }
    .success { background-image: url('https://i.postimg.cc/ZnFc7yKm/A-simple-icon-style-illustration-of-a-crown-centered-on-a-transparent-or-light-background-The-crow.jpg');
               background-size: cover;
               background-position: center;
             }

    .gradient-sub {
      font-family: 'Orbitron', sans-serif;
      font-size: 25px;
      font-weight: withe;
      color: #F0FFFF;
      position: relative;
      display: inline-block;
      text-shadow: 2px 2px 6px #001f4d;
      
    }  
    .gradient-stroke {
      font-family: 'Orbitron', sans-serif;
      font-size: 80px;
      font-weight: bold;
      background: linear-gradient(to bottom, #f9d976, #b87333); 
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      color: #2c3e50;
      position: relative;
      display: inline-block;
      
    }

    .gradient-stroke::before {
      webkit-text-stroke: 60px transparent; 
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      font-family: inherit;
      font-size: inherit;
      font-weight: inherit;
      background: linear-gradient(to bottom, #f9d976, #b87333); /* 淺金 → 銅金 */
      -webkit-background-clip: text;
      color: transparent;
      filter: drop-shadow(0 0 2px #f9d976);
      z-index: -1;
      -webkit-text-stroke: 2px #001f4d; 
      text-shadow: 2px 2px 6px #001f4d; 
      } 
   .missile {
        position: absolute;
        width: 40px;
        height: 10px;
        background: linear-gradient(to right, #f00, #fff);
        border-radius: 5px;
        top: 50%;
        left: -50px;
        transform: rotate(10deg);
        animation: fly 3s linear forwards;
        }

    @keyframes fly {
        0% { left: -50px; top: 50%; }
        100% { left: 100vw; top: 30%; }
        }

    .trail {
        position: absolute;
        width: 5px;
        height: 5px;
        background: orange;
        border-radius: 50%;
        animation: fade 1s linear forwards;
        }

    @keyframes fade {
        0% { opacity: 1; transform: scale(1); }
        100% { opacity: 0; transform: scale(2); }
        }
  </style>
</head>
<body background="https://i.postimg.cc/44YqXXBQ/2025-08-15-110625.jpg">
  <h1 class="gradient-stroke" data-text="DadCraft" style="font-size: 80px; margin-bottom: 20px;">DadCraft</h1>
  <h2 class="gradient-sub" data-text="PROTECT YOUR RICH OIL DADDY" style="font-size: 40px; margin-bottom: 0;">PROTECT YOUR RICH OIL DADDY</h2>
   <div id="maze-container">
        <div id="maze">
        </div>
  </div>

  <button onclick="resetAndSimulate()">重新投胎</button>
  <script>
    const size = 15;
    const maze = [];
    const mazeDiv = document.getElementById('maze');
    const center = [7, 7];
    let animationStopped = false;

    function createMaze() {
      mazeDiv.innerHTML = '';
      for (let y = 0; y < size; y++) {
        maze[y] = [];
        for (let x = 0; x < size; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell path';
          mazeDiv.appendChild(cell);
          maze[y][x] = { el: cell, type: 'path' };
        }
      }

      // Add borders
      for (let i = 0; i < size; i++) {
        maze[0][i].type = 'wall';
        maze[0][i].el.className = 'cell wall';
        maze[i][0].type = 'wall';
        maze[i][0].el.className = 'cell wall';
        maze[i][size-1].type = 'wall';
        maze[i][size-1].el.className = 'cell wall';
        maze[size-1][i].type = 'wall';
        maze[size-1][i].el.className = 'cell wall';
      }

      // Add center
      maze[center[1]][center[0]].type = 'center';
      maze[center[1]][center[0]].el.className = 'cell center';

      // Add oil wells
      for (let i = 0; i < 5; i++) {
        const ox = Math.floor(Math.random() * (size - 4)) + 2;
        const oy = Math.floor(Math.random() * (size - 4)) + 2;
        if (maze[oy][ox].type === 'path') {
          maze[oy][ox].type = 'oil';
          maze[oy][ox].el.className = 'cell oil';
        }
      }

      // Add internal walls
      for (let i = 2; i < size - 2; i += 2) {
        for (let j = 2; j < size - 2; j++) {
          if (Math.random() < 0.3 && maze[i][j].type === 'path') {
            maze[i][j].type = 'wall';
            maze[i][j].el.className = 'cell wall';
          }
        }
      }
    }

    function bfs(start) {
      const queue = [start];
      const visited = Array.from({ length: size }, () => Array(size).fill(false));
      const prev = Array.from({ length: size }, () => Array(size).fill(null));
      visited[start[1]][start[0]] = true;

      while (queue.length > 0) {
        const [x, y] = queue.shift();
        if (x === center[0] && y === center[1]) break;
        for (const [dx, dy] of [[0,1],[1,0],[0,-1],[-1,0]]) {
          const nx = x + dx, ny = y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size &&
              !visited[ny][nx] &&
              (maze[ny][nx].type === 'path' || maze[ny][nx].type === 'center')) {
            visited[ny][nx] = true;
            prev[ny][nx] = [x, y];
            queue.push([nx, ny]);
          }
        }
      }

      // Reconstruct path
      let path = [];
      let cur = center;
      while (cur && !(cur[0] === start[0] && cur[1] === start[1])) {
        path.push(cur);
        cur = prev[cur[1]][cur[0]];
      }
      if (cur) path.push(start);
      return path.reverse();
    }

  function animatePath(path, label) {
    let i = 0;
    function step() {
      if (animationStopped) return;
      if (i < path.length) {
        const [x, y] = path[i];
        const cell = maze[y][x];
        
        const currentClass = maze[y][x].el.className;

        if (
            (currentClass.includes('visited-you') && label === 'Z') ||
            (currentClass.includes('zombie') && label === 'YOU')
          ) {
              maze[y][x].el.className = 'cell overlap';
            } else {
                    maze[y][x].el.className =
                    label === 'YOU' ? 'cell visited-you' :
                    label === 'Z' ? 'cell zombie' :
                    'cell visited';
            }

        if (cell.type === 'center') {
          cell.el.className = 'cell success';
          animationStopped = true;
          if (label === 'YOU') {
            alert('恭喜你！來逛逛最新的保石捷！\nhttps://www.porsche.com/taiwan/zh-tw/');
        } else {
            alert('其實你並沒有一個富爸爸\n或許有人一出生，就在羅馬……');
          }
        return;
      } else {
        cell.el.className = label === 'YOU' ? 'cell visited-you' : 'cell visited';
      }

      i++;
      setTimeout(step, 100);
      }
    }
    step();
    }

    

    function resetAndSimulate() {
      animationStopped = false;
      createMaze();
      const edges = [];
      for (let i = 1; i < size - 1; i++) {
        edges.push([i, 1]);
        edges.push([i, size - 2]);
        edges.push([1, i]);
        edges.push([size - 2, i]);
      }
      const selected = [];
      while (selected.length < 5) {
        const candidate = edges[Math.floor(Math.random() * edges.length)];
        if (!selected.some(([x, y]) => x === candidate[0] && y === candidate[1])) {
          selected.push(candidate);
        }
      }

      selected.forEach((start, index) => {
        const label = index === 0 ? 'YOU' : 'Z'; 
        maze[start[1]][start[0]].el.className = label === 'YOU' ? 'cell visited-you' : 'cell zombie'
        const path = bfs(start);
        if (path.length > 0) {
          setTimeout(() => animatePath(path, label), index * 200);
        }
      });
    }
    const missile = document.getElementById('missile');

    // 模擬尾焰
    setInterval(() => {
      const trail = document.createElement('div');
      trail.className = 'trail';
      trail.style.left = missile.offsetLeft + 'px';
      trail.style.top = missile.offsetTop + 'px';
      document.body.appendChild(trail);

      setTimeout(() => trail.remove(), 1000);
    }, 100);
    createMaze();
  
  </script>


</body>
</html>
